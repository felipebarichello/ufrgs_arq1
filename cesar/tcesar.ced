; --- STARTUP ---

	mov #stack, r6
	jsr r7, __main
	hlt


;+=================================================================================================+


;VARIÁVEIS

in_buf: DAW [36] ;Buffer de entrada


;PROGRAMA

__main:
	jsr r7, _stdio_clear
	
	jsr r7, _stdio_in
	mov #in_buf, r3
	jmp _stdio_input_flush

	rts r7


;+=================================================================================================+
;|                                                                                                 |
;|                                         BIBLIOTECAS                                             |
;|       																				           |
;+-------------------------------------------------------------------------------------------------+

; <stdio>


;stdio_clear()
_stdio_clear:
	mov #display, r5
	
stdio_clear_loop_even:
	clr (r5)+
	cmp r5, #display+35

	;`ble` em vez de `bls` por causa do overflow
	ble stdio_clear_loop_even

	inc r5

stdio_clear_loop_odd:
	clr -(r5)
	cmp r5, #display+1

	;`bgt` em vez de `bhi` por causa do overflow
	bgt stdio_clear_loop_odd
	rts r7


;stdio_in(buffer[36] r3)
;Receber input do usuário e armazenar no buffer (36 palavras) cujo endereço inicial está em r3.
_stdio_in:
	mov #display, r5
	mov #255, timdt
	clr r1

stdio_in_cursor:
	clr ints

	;Caso o display esteja cheio, não tenta desenhar o cursor
	;`bgt` em vez de `bhi` por causa do overflow
	cmp r5, #display+35
	bgt stdio_in_read

	tst r1
	bne stdio_in_cursor_hide

	mov #'|', (r5)
	inc r1
	jmp stdio_in_read

stdio_in_cursor_hide:
	clr (r5)
	dec r1
	jmp stdio_in_read

stdio_in_wait:
	mov ints, r0
	and #h01, r0
	bne stdio_in_cursor

stdio_in_read:
	tst tecst
	beq stdio_in_wait
	mov tecdt, r4
	clr tecst

	cmp r5, #display+35
	bgt stdio_in_skip_clear

	clr (r5)

stdio_in_skip_clear:
stdio_in_backspace:
	cmp r4, #h08 ;Backspace
	bne stdio_in_return

	cmp r5, #display
	beq stdio_in_wait
	dec r5
	clr (r5)
	jmp stdio_in_wait

stdio_in_return:
	cmp r4, #h0D ;Return
	bne stdio_in_default
	rts r7

;Não é caractere especial. Imprime-o no display.
stdio_in_default:
	cmp r5, #display+35

	;`bgt` em vez de `bhi` por causa do overflow
	bgt stdio_in_wait
	
	mov r4, (r5)
	inc r5
	jmp stdio_in_wait


;stdio_input_flush(buffer[36] r3)
;Armazenar o conteúdo do display no buffer (36 palavras) cujo endereço inicial está em r3 e limpar o display.
_stdio_input_flush:
	clr r4		  ;Iterador

stdio_input_flush_loop:
	mov display(r4), (r3)+
	clr display(r4)
	inc r4
	cmp r4, #36
	bcs stdio_input_flush_loop ;Quando `r4 = 36`, o buffer está cheio

	rts r7

;+-------------------------------------------------------------------------------------------------+




;+-------------------------------------------------------------------------------------------------+
;|                                                                                                 |
;|                                      ENDEREÇOS ESPECIAIS                                        |
;|       																				           |
;+-------------------------------------------------------------------------------------------------+

stack: EQU hFF80 ;Fundo da stack

ORG hFFBE
ivet: DW ;Vetor de interrupção - endereço da ISR (Interrupt Service Routine)

ORG hFFD7
timdt: DB ;(BYTE) Timer base time
ints:  DB ;(BYTE) Interrupt Status - Monitoramento do estado das interrupções
inte:  DB ;(BYTE) Interrupt Enable - Controle de habilitação das interrupções
tecst: DB ;(BYTE) Se o conteúdo deste endereço de memória for h80 então existe tecla disponível
tecdt: DB ;(BYTE) Dado do Teclado - Endereço a ser lido caso exista uma tecla disponível
display: DAB [36] ;(BYTE) 36 bytes do visor
