; --- STARTUP ---

	mov #stack, r6
	jsr r7, __main
	hlt


;+=================================================================================================+


;VARIÁVEIS

in_buf: DAW [36] ;Buffer de entrada
txt_press_any_1: DAW 'Pressione qualquer tecla para', 0
txt_press_any_2: DAW 'continuar quando o icone a direita', 0
txt_press_any_3: DAW 'estiver presente', 0
txt_welcome: DAW 'Bem-vindo(a) a Iulius Caesar', 0
txt_enter_word: DAW 'Insira a palavra secreta', 0
txt_enter_word_prompt: DAW 'Palavra: ', 0


;PROGRAMA

__main:
	jsr r7, _stdio_init

	mov #txt_press_any_1, r2
	jsr r7, _print_and_wait

	mov #txt_press_any_2, r2
	jsr r7, _print_and_wait

	mov #txt_press_any_3, r2
	jsr r7, _print_and_wait

	mov #txt_welcome, r2
	jsr r7, _print_and_wait

	mov #txt_enter_word, r2
	jsr r7, _print_and_wait

	mov #txt_enter_word_prompt, r2
	jsr r7, _stdio_print
	jsr r7, _stdio_in

	mov #in_buf, r3
	jsr r7, _stdio_input_flush
	jsr r7, _stdio_anykey
	jsr r7, _stdio_clear

	mov #in_buf, r2
	jsr r7, _stdio_print
	
	; jsr r7, _stdio_in
	; mov #in_buf, r3
	; jmp _stdio_input_flush

	rts r7


_print_and_wait:
	jsr r7, _stdio_print
	jsr r7, _stdio_anykey
	jsr r7, _stdio_clear
	rts r7


;+=================================================================================================+
;|                                                                                                 |
;|                                         BIBLIOTECAS                                             |
;|       																				           |
;+-------------------------------------------------------------------------------------------------+

; <stdio>


stdio_text_end:    DW ;Endereço de memória do primeiro byte vazio do display
stdio_input_start: DW ;Endereço de memória do primeiro byte do display que contém input do usuário


;stdio_init()
;Inicializar o display e o teclado.
_stdio_init:
	jsr r7, _stdio_clear   ;Limpar o display
	rts r7


;stdio_print(buffer r2)
;Imprimir a null-terminated string do buffer cujo endereço inicial está em r2 no display.
;Continua o texto anterior caso não tenha sido limpo.
_stdio_print:
	mov stdio_text_end, r5
	mov r2, r3

stdio_print_loop:
	cmp r5, #display+35
	bgt stdio_print_end ;Para caso o display esteja cheio
	mov (r3)+, r4
	beq stdio_print_end ;Para caso o texto tenha terminado
	mov r4, (r5)
	inc r5
	jmp stdio_print_loop

stdio_print_end:
	mov r5, stdio_text_end
	rts r7


;stdio_clear()
;Limpar o display.
_stdio_clear:
	mov stdio_text_end, r5
	sub #display+1, r5 ;r5 agora contém o offset do último byte com texto do display
	blt stdio_clear_end ;Caso o display já esteja vazio, terminar
	
stdio_clear_loop:
	clr display(r5)
	sob r5, stdio_clear_loop
	clr display ;Limpar o primeiro byte do display

stdio_clear_end:
	mov #display, stdio_text_end
	rts r7


;stdio_in()
;Receber input do usuário até `return` ser pressionado.
;Usar `_stdio_input_flush` para armazenar o conteúdo do display em um buffer
_stdio_in:
	clr tecst
	mov stdio_text_end, r5
	mov r5, stdio_input_start
	mov #255, timdt
	clr r1

stdio_in_cursor:
	clr ints

	;Caso o display esteja cheio, não tenta desenhar o cursor
	;`bgt` em vez de `bhi` por causa do overflow
	cmp r5, #display+35
	bgt stdio_in_read

	tst r1
	bne stdio_in_cursor_hide

	mov #'|', (r5)
	inc r1
	jmp stdio_in_read

stdio_in_cursor_hide:
	clr (r5)
	dec r1
	jmp stdio_in_read

stdio_in_wait:
	mov ints, r0
	and #h01, r0
	bne stdio_in_cursor

stdio_in_read:
	tst tecst
	beq stdio_in_wait
	mov tecdt, r4
	clr tecst

	cmp r5, #display+35
	bgt stdio_in_skip_clear

	clr (r5)

stdio_in_skip_clear:
stdio_in_backspace:
	cmp r4, #h08 ;Backspace
	bne stdio_in_return

	cmp r5, #display
	beq stdio_in_wait
	dec r5
	clr (r5)
	jmp stdio_in_wait

stdio_in_return:
	cmp r4, #h0D ;Return
	bne stdio_in_default

	mov r5, stdio_text_end
	rts r7

;Não é caractere especial. Imprime-o no display.
stdio_in_default:
	cmp r5, #display+35

	;`bgt` em vez de `bhi` por causa do overflow
	bgt stdio_in_wait
	
	mov r4, (r5)
	inc r5
	jmp stdio_in_wait


;stdio_input_flush(buffer[36] r3)
;Armazenar o conteúdo do display no buffer (36 palavras) cujo endereço inicial está em r3 e limpar o display.
_stdio_input_flush:
	mov stdio_input_start, r4 ;Iterador
	sub #display, r4 ;r4 agora contém o offset do buffer inicial
	mov #36, r5

;Loop começa em `stdio_input_start` e termina em `stdio_text_end`
stdio_input_flush_loop:
	mov display(r4), (r3)+
	beq stdio_input_flush_end
	clr display(r4)
	inc r4
	cmp r4, r5
	bcs stdio_input_flush_loop ;Quando `r4 = 36`, o buffer está cheio

stdio_input_flush_end:
	mov stdio_input_start, stdio_text_end
	rts r7
	

;stdio_wait()
;Pausar o programa até que uma tecla qualquer seja pressionada.
_stdio_anykey:
	mov #h3E, display+35 ;Desenhar '>' no canto direito
	clr tecst

_stdio_anykey_wait:
	tst tecst
	beq _stdio_anykey_wait
	
	rts r7

;+-------------------------------------------------------------------------------------------------+




;+-------------------------------------------------------------------------------------------------+
;|                                                                                                 |
;|                                      ENDEREÇOS ESPECIAIS                                        |
;|       																				           |
;+-------------------------------------------------------------------------------------------------+

stack: EQU hFF80 ;Fundo da stack

ORG hFFBE
ivet: DW ;Vetor de interrupção - endereço da ISR (Interrupt Service Routine)

ORG hFFD7
timdt: DB ;(BYTE) Timer base time
ints:  DB ;(BYTE) Interrupt Status - Monitoramento do estado das interrupções
inte:  DB ;(BYTE) Interrupt Enable - Controle de habilitação das interrupções
tecst: DB ;(BYTE) Se o conteúdo deste endereço de memória for h80 então existe tecla disponível
tecdt: DB ;(BYTE) Dado do Teclado - Endereço a ser lido caso exista uma tecla disponível
display: DAB [36] ;(BYTE) 36 bytes do visor
