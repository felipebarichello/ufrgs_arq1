null: DW 0 ;Endereço nulo

; --- STARTUP ---

	mov #stack, r6
	jsr r7, __main
	hlt
	jmp 0 ;Zerar o PC caso o usuário não tenha feito isso após o fim do programa


;+=================================================================================================+


;VARIÁVEIS

;/[DEBUG]
debug_warning: DAW 'ATENCAO: MODO DEBUG ATIVADO', 0
;[/DEBUG]
secret_word: DAW [37] ;Palavra secreta
secret_word_hidden: DAW [37] ;Palavra secreta com os caracteres não descobertos substituídos por '_'
lives: DAW [3] ;Número de vidas, em ASCII. Deixar em ASCII é mais otimizado para imprimir no display.
clock: DW ;Quantos ticks de 250ms se passaram desde o início do jogo
strbuf36: DAW [37] ;Buffer de string do tamanho do display
txt_press_any_1: DAW 'Pressione qualquer tecla para', 0
txt_press_any_2: DAW 'continuar quando o icone a direita', 0
txt_press_any_3: DAW 'estiver presente', 0
txt_welcome: DAW 'Bem-vindo(a) a Iulius Caesar', 0
txt_enter_word: DAW 'Insira a palavra secreta', 0
txt_enter_word_prompt: DAW 'Palavra: ', 0
txt_enter_lives: DAW 'Quantas vidas (1-99): ', 0
txt_enter_lives_invalid: DAW 'Valor invalido!', 0
txt_symbol_heart: DAW 'Vidas: ', 0
txt_space: DAW ' ', 0


;PROGRAMA

__main:
	jsr r7, _stdio_init
	jsr r7, _isr_init

	;[DEBUG]
	; mov #debug_warning, r2
	; jsr r7, _print_and_wait

	; mov #'D', secret_word
	; mov #'e', secret_word+2
	; mov #'B', secret_word+4
	; mov #'u', secret_word+6
	; mov #'G', secret_word+8
	; clr secret_word+10 ;Null terminator

	; mov #'0', lives
	; mov #'7', lives+2
	; clr lives+4 ;Null terminator

	; jmp game_start
	;[/DEBUG]
	
	mov #txt_press_any_1, r2
	jsr r7, _print_and_wait

	mov #txt_press_any_2, r2
	jsr r7, _print_and_wait

	mov #txt_press_any_3, r2
	jsr r7, _print_and_wait

	mov #txt_welcome, r2
	jsr r7, _print_and_wait

	mov #txt_enter_word, r2
	jsr r7, _print_and_wait

enter_word_prompt:
	mov #txt_enter_word_prompt, r2
	jsr r7, _stdio_print
	jsr r7, _stdio_in
	mov #secret_word, r3
	jsr r7, _stdio_input_flush
	jsr r7, _str_to_upper

enter_lives_loop:
	jsr r7, _stdio_clear
	mov #txt_enter_lives, r2
	jsr r7, _stdio_print
	jsr r7, _stdio_in
	mov #strbuf36, r3
	jsr r7, _stdio_input_flush
	jsr r7, _set_lives
	bne game_start

 	;Erro parseando o número de vidas
	jsr r7, _stdio_clear
	mov #txt_enter_lives_invalid, r2
	jsr r7, _stdio_print
	jsr r7, _stdio_anykey
	br enter_lives_loop

game_start:
	jsr r7, _stdio_clear

	clr clock

	;Copiar a palavra secreta para a palavra secreta escondida, substituindo os caracteres por '_'
	mov #secret_word, r3
	mov #secret_word_hidden, r4

game_hide_word_loop:
	mov (r3)+, r0
	beq game_hide_word_end
	
	cmp r0, #' '
	beq game_hide_word_skip_replace

	mov #'_', r0

game_hide_word_skip_replace:
	mov r0, (r4)+
	br game_hide_word_loop

game_hide_word_end:
	;Iniciar o timer com interrupção
	mov #_update_timer, isr_timer
	jsr r7, _isr_enable_timer
	mov #250, timdt

game_loop:
	jsr r7, _stdio_clear

	mov #secret_word_hidden, r2
	jsr r7, _stdio_print ;Imprimir a palavra secreta à esquerda

	mov #display+27, stdio_cursor
	mov #txt_symbol_heart, r2
	jsr r7, _stdio_print ;Imprimir o símbolo de coração à direita

	mov #lives, r2 ;Já está em ASCII
	jsr r7, _stdio_print ;Imprimir o número de vidas à direita

	rts r7


;print_and_wait(buffer r2)
_print_and_wait:
	jsr r7, _stdio_print
	jsr r7, _stdio_anykey
	jsr r7, _stdio_clear
	rts r7


;set_lives(buffer r3)
;Verificar se o buffer cujo endereço inicial está em r3 contém um número de vidas válido.
;Preenche as vidas em `lives` caso seja válido.
;Retorna 1 caso seja válido, 0 caso contrário.
_set_lives:
	mov (r3)+, r4
	beq set_lives_false ;0 dígitos
	mov #2, r5 ;No máximo 2 dígitos

set_lives_loop:
	cmp r4, #'9'
	bhi set_lives_false ;Caractere não é um dígito
	cmp r4, #'0'
	bcs set_lives_false ;Caractere não é um dígito

	;Caractere é um dígito
	;Novo caractere
	mov (r3)+, r4
	beq set_lives_2digits
	sob r5, set_lives_loop
	br set_lives_false ;Mais de 2 dígitos

set_lives_2digits:
	dec r5
	bne set_lives_padding

	;Dois dígitos
	mov -6(r3), lives
	br set_lives_second_digit

set_lives_padding:
	;Um dígito. Adicionar um zero à esquerda
	mov #'0', lives

set_lives_second_digit:
	mov -4(r3), lives+2

	;Verificar se não é 0
	cmp lives+2, #'0'
	bne set_lives_true
	cmp lives, #'0'
	beq set_lives_false

set_lives_true:
	mov #1, r1
	rts r7

set_lives_false:
	clr r1
	rts r7


;update_timer()
;Interrupção do timer.
_update_timer:
	inc clock
	rts r7


;+=================================================================================================+
;|                                                                                                 |
;|                                         BIBLIOTECAS                                             |
;|       																				           |
;+-------------------------------------------------------------------------------------------------+

; <str>


;str_to_upper(buffer r3)
;Converter a null-terminated string do buffer cujo endereço inicial está em r3 para maiúsculas.
_str_to_upper:
	mov r3, r2

str_to_upper_loop:
	mov (r2)+, r4
	beq str_to_upper_end
	cmp r4, #'a'
	bcs str_to_upper_loop

	cmp r4, #'z'
	bhi str_to_upper_loop

	;r4 contém um caractere minúsculo
	;Converter para maiúsculo
	add #-32, r4 ;'A' - 'a' = -32
	mov r4, -2(r2)
	br str_to_upper_loop

str_to_upper_end:
	rts r7


;str_to_lower(buffer r3)
;Converter a null-terminated string do buffer cujo endereço inicial está em r3 para minúsculas.
_str_to_lower:
	mov r3, r2

str_to_lower_loop:
	mov (r2)+, r4
	beq str_to_lower_end
	cmp r4, #'A'
	bcs str_to_lower_loop

	cmp r4, #'Z'
	bhi str_to_lower_loop

	;r4 contém um caractere maiúsculo
	;Converter para minúsculo
	add #32, r4 ;'a' - 'A' = 32
	mov r4, -2(r2)
	br str_to_lower_loop

str_to_lower_end:
	rts r7


;str_from_u16(u16 r0, string r5)
;Converte o inteiro unsigned para null-terminated string
;r0: Endereço do algarismo mais significativo não-nulo ou zero caso todos os algarismos sejam nulos
;r1: #10
;r2: -
;r3: -
;r4: -
_str_from_u16:
	add #10, r5  ;r5 agora aponta para o último caractere da string
	clr (r5)     ;Null terminator
	mov #5, r4   ;Iterador. Um u16 consegue ter no máximo 5 dígitos 
	mov #10, r1  ;Divisor
	tst r0
	bne str_from_u16_div_loop
	mov r5, r0
	sub #2, r0 ;r0 agora aponta para o último caractere da string
	br str_from_u16_padding_loop

str_from_u16_div_loop:
	beq str_from_u16_padding ;Quando o dividendo for 0, terminar

	mov r4, -(r6) ;_math_div_u16 altera r4
	jsr r7, _math_div_u16 ;Dividir por 10
	mov (r6)+, r4
	;r2 contém o número com o dígito menos significativo removido
	;r3 contém o dígito menos significativo

	add #'0', r3  ;Converter o dígito de BCD para ASCII
	mov r3, -(r5) ;Armazenar o caractere do dígito na string
	mov r2, r0    ;Preparar o dividendo para a próxima iteração
	sob r4, str_from_u16_div_loop

	mov r5, r0 ;r0 contém o endereço do algarismo mais significativo não-nulo
	br str_from_u16_end ;Se todos os dígitos foram usados, não precisa preencher com zeros

;Senão, preencher os dígitos não usados com zeros
str_from_u16_padding:
	mov r5, r0 ;r0 contém o endereço do algarismo mais significativo não-nulo

str_from_u16_padding_loop:
	mov #'0', -(r5)
	sob r4, str_from_u16_padding_loop ;r4 contém o número de dígitos não preenchidos

str_from_u16_end:
	rts r7

;+-------------------------------------------------------------------------------------------------+

; <math>


;math_div_u16(u16 r0, u16 r1)
;Divide r0 por r1 e armazena o quociente em r2 e o resto em r3
;Caso o divisor seja 0, retorna 0 em r2 e coloca o dividendo em r3
_math_div_u16:
	;Divisão por 0
	tst r1
	beq math_div_u16_byzero
	
	mov #16, r4 ;Iterador
	clr r3 ;Dividendo parcial

math_div_u16_loop:
	;Extrair o bit mais significativo do dividendo
	ccc C
	rol r0 ;Não poderia ser com `shl` pois o bit mais significativo se comporta como sinal
	rol r3

	;Caso o dividendo parcial seja maior ou igual ao divisor, subtrair o divisor do dividendo parcial
	cmp r3, r1
	bcs math_div_u16_not_sub

	sub r1, r3
	scc C ;Inserir 1 no bit correspondente do quociente
	br math_div_u16_loop_end

math_div_u16_not_sub:
	ccc C ;Inserir 0 no bit correspondente do quociente

math_div_u16_loop_end:
	rol r2 ;Inserir o bit no quociente
	sob r4, math_div_u16_loop

math_div_u16_end:
	rts r7

math_div_u16_byzero:
	clr r2
	mov r0, r3
	rts r7

;+-------------------------------------------------------------------------------------------------+

; <stdio>


stdio_cursor:    DW   ;Endereço de memória do primeiro byte vazio do display
stdio_input_start: DW ;Endereço de memória do primeiro byte do display que contém input do usuário


;stdio_init()
;Inicializar o display e o teclado.
_stdio_init:
	clr #stdio_cursor ;Mandar limpar o display inteiro
	jsr r7, _stdio_clear   ;Limpar o display
	rts r7


;stdio_print(buffer r2)
;Imprimir a null-terminated string do buffer cujo endereço inicial está em r2 no display.
;Continua o texto anterior caso não tenha sido limpo.
_stdio_print:
	mov stdio_cursor, r5

stdio_print_loop:
	cmp r5, #display+35
	bgt stdio_print_end ;Para caso o display esteja cheio
	mov (r2)+, r4
	beq stdio_print_end ;Para caso o texto tenha terminado
	mov r4, (r5)
	inc r5
	br stdio_print_loop

stdio_print_end:
	mov r5, stdio_cursor
	rts r7


;stdio_clear()
;Limpar o display.
_stdio_clear:
	mov stdio_cursor, r5
	sub #display, r5 ;r5 agora contém o offset do último byte com texto do display
	ble stdio_clear_end ;Caso o display já esteja vazio, terminar
	
stdio_clear_loop:
	clr 65499(r5) ;Por algum motivo, escrever `display-1(r5)` não funciona
	sob r5, stdio_clear_loop
	mov #display, stdio_cursor

stdio_clear_end:
	rts r7


;stdio_free()
;Virtualmente limpar o display sem alterar o conteúdo do display.
;É mais otimizado que `stdio_clear` pois não precisa escrever no display.
;Deve ser usado quando o conteúdo do display será sobrescrito.
_stdio_free:
	mov #display, stdio_cursor
	rts r7


;stdio_in()
;Receber input do usuário até `return` ser pressionado.
;Usar `_stdio_input_flush` para armazenar o conteúdo do display em um buffer
_stdio_in:
	clr tecst
	mov stdio_cursor, r5
	mov r5, stdio_input_start
	mov #255, timdt
	clr r1

stdio_in_cursor:
	clr ints

	;Caso o display esteja cheio, não tenta desenhar o cursor
	;`bgt` em vez de `bhi` por causa do overflow
	cmp r5, #display+35
	bgt stdio_in_read

	tst r1
	bne stdio_in_cursor_hide

	mov #'|', (r5)
	inc r1
	br stdio_in_read

stdio_in_cursor_hide:
	clr (r5)
	dec r1
	br stdio_in_read

stdio_in_wait:
	mov ints, r0
	and #h01, r0
	bne stdio_in_cursor

stdio_in_read:
	tst tecst
	beq stdio_in_wait
	mov tecdt, r4
	clr tecst

	cmp r5, #display+35
	bgt stdio_in_skip_clear

	clr (r5)

stdio_in_skip_clear:
stdio_in_backspace:
	cmp r4, #h08 ;Backspace
	bne stdio_in_return

	cmp r5, stdio_input_start
	beq stdio_in_wait
	dec r5
	clr (r5)
	br stdio_in_wait

stdio_in_return:
	cmp r4, #h0D ;Return
	bne stdio_in_default

	mov r5, stdio_cursor
	rts r7

;Não é caractere especial. Imprime-o no display.
stdio_in_default:
	cmp r5, #display+35

	;`bgt` em vez de `bhi` por causa do overflow
	bgt stdio_in_wait
	
	mov r4, (r5)
	inc r5
	br stdio_in_wait


;stdio_input_flush(buffer r3)
;Armazenar o conteúdo do display no buffer cujo endereço inicial está em r3 e limpar o display.
_stdio_input_flush:
	mov r3, r2
	mov stdio_input_start, r4 ;Iterador
	sub #display, r4 ;r4 agora contém o offset do buffer inicial
	mov #36, r5

;Loop começa em `stdio_input_start` e termina em `stdio_cursor`
stdio_input_flush_loop:
	mov display(r4), (r2)+
	beq stdio_input_flush_end
	clr display(r4)
	inc r4
	cmp r4, r5
	bcs stdio_input_flush_loop ;Quando `r4 = 36`, o buffer está cheio

stdio_input_flush_end:
	mov stdio_input_start, stdio_cursor
	rts r7


;stdio_anykey()
;Pausar o programa até que uma tecla qualquer seja pressionada.
_stdio_anykey:
	mov display+35, r4 ;Guardar o último byte do display
	mov #h3E, display+35 ;Desenhar '>' no último byte do display
	jsr r7, _isr_waitfor_keyboard

	mov r4, display+35 ;Recuperar o último byte do display
	rts r7

;+-------------------------------------------------------------------------------------------------+

; <isr>

;Ponteiro para a subrotina a ser chamada quando ocorrer uma interrupção do timer.
isr_timer:    DW 0

;Ponteiro para a subrotina a ser chamada quando ocorrer uma interrupção do teclado.
;Dentro da ISR do teclado, tecdt contém o caractere pressionado e não é alterado.
;O usuário só poderá inserir um novo caractere após a ISR do teclado terminar.
isr_keyboard: DW 0


;isr_init()
;Inicializar a rotina de interrupções.
_isr_init:
	clr isr_timer ;Null
	clr isr_keyboard ;Null
	mov #i_isr_routine, ivet
	mov #h80, inte
	clr ints
	rts r7


;isr_enable_timer()
_isr_enable_timer:
	or #h01, inte  ;Habilitar interrupção do timer
	and #hFE, ints ;Limpar status do timer
	rts r7


;isr_disable_timer()
_isr_disable_timer:
	and #hFE, inte ;Desabilitar interrupção do timer
	clr isr_timer  ;isr_timer = NULL
	rts r7


;isr_enable_keyboard()
_isr_enable_keyboard:
	or #h02, inte  ;Habilitar interrupção do teclado
	and #hFD, ints ;Limpar status do teclado
	clr tecst      ;Limpar status do teclado
	rts r7


;isr_disable_keyboard()
_isr_disable_keyboard:
	and #hFD, inte   ;Desabilitar interrupção do teclado
	clr isr_keyboard ;isr_keyboard = NULL
	rts r7


;Rotina a ser chamada quando ocorrer uma interrupção
i_isr_routine:
isr_routine_test_timer:
	tst isr_timer
	beq isr_routine_test_keyboard ;isr_timer é NULL
	
	;Interrupção de timer está habilitada
	mov ints, -(r6) ;Evitando utilizar os registradores de uso geral para poderem servir como uma interface
	and #h01, (r6)+ ;entre o programa e a interrupção
	beq isr_routine_test_keyboard ;Timer não causou a interrupção

	;Timer causou a interrupção
	mov isr_timer, -(r6)
	jsr r7, ((r6)+)
	and #hFE, ints ;Limpar status do timer

isr_routine_test_keyboard:
	tst isr_keyboard
	beq isr_routine_end ;isr_keyboard é NULL

	;Interrupção de teclado está habilitada
	mov ints, -(r6)
	and #h02, (r6)+
	beq isr_routine_end ;Teclado não causou a interrupção

	;Teclado causou a interrupção
	mov isr_keyboard, -(r6)
	jsr r7, ((r6)+)
	and #hFD, ints   ;Limpar status do teclado
	clr tecst        ;Permitir que o teclado cause outra interrupção

isr_routine_end:
	rti


;isr_waitfor_keyboard()
;Pausar o programa até que uma tecla seja pressionada.
_isr_waitfor_keyboard:
	mov #_isr_waitfor_keyboard_interrupt, isr_keyboard
	jsr r7, _isr_enable_keyboard
	clr r0

isr_waitfor_keyboard_loop:
	tst r0
	beq isr_waitfor_keyboard_loop

	jsr r7, _isr_disable_keyboard
	rts r7

_isr_waitfor_keyboard_interrupt:
	inc r0
	rts r7




;+-------------------------------------------------------------------------------------------------+
;|                                                                                                 |
;|                                      ENDEREÇOS ESPECIAIS                                        |
;|       																				           |
;+-------------------------------------------------------------------------------------------------+

stack: EQU hFF80 ;Fundo da stack

ORG hFFBE
ivet: DW ;Vetor de interrupção - endereço da ISR (Interrupt Service Routine)

ORG hFFD7
timdt: DB ;(BYTE) Timer base time
ints:  DB ;(BYTE) Interrupt Status - Monitoramento do estado das interrupções
inte:  DB ;(BYTE) Interrupt Enable - Controle de habilitação das interrupções
tecst: DB ;(BYTE) Se o conteúdo deste endereço de memória for h80 então existe tecla disponível
tecdt: DB ;(BYTE) Dado do Teclado - Endereço a ser lido caso exista uma tecla disponível
display: DAB [36] ;(BYTE) 36 bytes do visor
