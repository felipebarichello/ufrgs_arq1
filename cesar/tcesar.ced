;ENDEREÇOS FIXOS (conforme as especificações do trabalho)

ORG h8000

lives: DW ;Número de vidas do jogador

;A palavra secreta a ser adivinhada. É inserida pelo usuário. Tem no máximo 25 caracteres.
;É uma array de bytes, conforme as especificações do trabalho,
;embora seja muito mais pesado computacionalmente e precisar de tratamento especial
;já que o Cesar não trabalha naturalmente com 8 bits.
secret_word: DAB [27] 


;+=================================================================================================+


;INICIALIZAÇÃO (independe do programa)

ORG 0

null: DW 0 ;Endereço nulo

; --- STARTUP ---

__startup:
	mov #stack, r6
	jsr r7, __main
	hlt
	jmp __startup ;Zerar o PC caso o usuário não tenha feito isso após o fim do programa


;+=================================================================================================+


;VARIÁVEIS E CONSTANTES

;Palavra secreta com os caracteres não descobertos substituídos por '_'.
;É basicamente um buffer do que é exibido no display para não fazer operações diretamente no display,
;o que é má prática e impediria o uso do display para outras coisas, como exibir mensagens de "letra já usada".
secret_word_hidden: DAW [37] 

;Máscara de bits que indica as letras já usadas
;0b00 -> Nem 'A', nem 'B' foram usados 
;0b01 -> 'A' foi usado, mas 'B' não
;0b10 -> 'B' foi usado, mas 'A' não
;0b11 -> 'A' e 'B' foram usados
;E assim segue até 'Z', que corresponde ao bit 0x0200_0000
;Os bits de 0x0400_0000 a 0x8000_0000 são ignorados
;
; 1º byte | 2º byte | 3º byte | 4º byte 
;0000 00ZY XWVU TSRQ PONM LKJI HGFE DCBA
guess_mask: DAW [2]

;Mapa que associa as letras de 'A' a 'P' a máscaras de bits com apenas um bit ligado
;A partir de 'Q', 'Q' deve ser subtraído do valor, e o primeiro byte de guess_mask deve ser usado
;
;guess_mask_map   = 0b0000_0001
;guess_mask_map+2 = 0b0000_0010
;guess_mask_map+4 = 0b0000_0100
;...
;guess_mask_map+30 = 0x8000
guess_mask_map: DAW h0001, h0002, h0004, h0008
				DAW h0010, h0020, h0040, h0080
				DAW h0100, h0200, h0400, h0800
				DAW h1000, h2000, h4000, h8000

clock: DW ;Quantos ticks de 250ms se passaram desde o início do jogo
strbuf36: DAW [37] ;Buffer de string do tamanho do display

;Strings estáticas
txt_press_any_1: DAW 'Pressione qualquer tecla para', 0
txt_press_any_2: DAW 'continuar quando o icone a direita', 0
txt_press_any_3: DAW 'estiver presente', 0
txt_welcome: DAW 'Bem-vindo(a) a Pascoa de Cesar', 0
txt_lore_prompt: DAW 'Deseja ler a lore? (s/n) ', 0
txt_lore_01: DAW 'Voce e Barrabas, um ladrao,', 0
txt_lore_02: DAW 'prisioneiro no imperio romano.', 0
txt_lore_03: DAW 'Voce foi pego novamente apos ja', 0
txt_lore_04: DAW 'ter sido liberado no passado.', 0
txt_lore_05: DAW 'Estamos no reinado do imperador', 0
txt_lore_06: DAW 'Tiberio Claudio Nero Cesar,', 0
txt_lore_07: DAW 'e estamos na semana de Pascoa.', 0
txt_lore_08: DAW 'Como e tradicao no imperio,', 0
txt_lore_09: DAW 'em epoca de Pascoa,', 0
txt_lore_10: DAW 'um prisioneiro sera solto e tera', 0
txt_lore_11: DAW 'a chance de se redimir.', 0
txt_lore_12: DAW 'Ja nao se usa mais a cruz.', 0
txt_lore_13: DAW 'O imperio agora adota o uso', 0
txt_lore_14: DAW 'da forca para as execucoes.', 0
txt_lore_15: DAW 'Cesar percebe que ha apenas', 0
txt_lore_16: DAW 'um prisioneiro dessa vez: voce.', 0
txt_lore_17: DAW 'Cesar entao pede a Poncio Pilatos,', 0
txt_lore_18: DAW 'o carrasco, proximo de se', 0
txt_lore_19: daw 'aposentar, para que transforme essa', 0
txt_lore_20: DAW 'decisao em um jogo, ja que nao quer', 0
txt_lore_21: DAW 'deixar voce sair impune sem esforco', 0
txt_lore_22: DAW 'apos ser libertado uma segunda vez.', 0
txt_lore_23: DAW 'Pilatos entao inventa um jogo.', 0
txt_lore_24: DAW 'Se voce acertar a palavra que', 0
txt_lore_25: DAW 'Pilatos pensou, voce sera ', 0
txt_lore_26: DAW 'libertado.', 0
txt_lore_27: DAW 'Senao, voce sera enforcado.', 0
txt_enter_word: DAW 'Insira a palavra secreta.', 0
txt_enter_word_max: DAW 'Ha um limite de 25 caracteres.', 0
txt_enter_word_prompt: DAW 'Palavra: ', 0
txt_enter_word_invalid: DAW 'Palavra invalida!', 0
txt_enter_lives: DAW 'Quantas vidas (1-99): ', 0
txt_enter_lives_invalid: DAW 'Valor invalido!', 0
txt_ui_lives: DAW 'Vidas: ', 0
txt_colon: DAW ':', 0
txt_game_lost: DAW 'Voce perdeu!', 0
txt_game_won: DAW 'Voce venceu!', 0
txt_time_elapsed: DAW 'Tempo de jogo: ', 0
txt_play_again_prompt: DAW 'Jogar novamente? (s/n) ', 0
txt_yn_invalid: DAW 'Entrada invalida!', 0
txt_yn_invalid_y: DAW 'Insira ', h27, 's', h27, ' para "sim",', 0
txt_yn_invalid_n: DAW 'ou ', h27, 'n', h27, ' para "nao".', 0
txt_exit: DAW '************************************', 0


;PROGRAMA

__main:
	jsr r7, _stdio_init
	jsr r7, _isr_init

	;Mensagens ao jogador	
	mov #txt_press_any_1, r2
	jsr r7, _print_and_wait

	mov #txt_press_any_2, r2
	jsr r7, _print_and_wait

	mov #txt_press_any_3, r2
	jsr r7, _print_and_wait

restart_point:
	jsr r7, _stdio_clear
	mov #txt_welcome, r2
	jsr r7, _print_and_wait

lore_prompt:
	;Perguntar se o jogador quer ler a lore
	mov #txt_lore_prompt, r2
	jsr r7, _stdio_print
	jsr r7, _stdio_yn
	bgt lore
	blt lore_input_invalid
	jmp skip_lore

lore_input_invalid:
	;Entrada inválida
	jsr r7, _stdio_clear
	mov #txt_yn_invalid, r2
	jsr r7, _print_and_wait
	mov #txt_yn_invalid_y, r2
	jsr r7, _print_and_wait
	mov #txt_yn_invalid_n, r2
	jsr r7, _print_and_wait
	br lore_prompt ;Repetir a pergunta

lore:
	jsr r7, _stdio_clear
	mov #txt_lore_01, r2
	jsr r7, _print_and_wait
	mov #txt_lore_02, r2
	jsr r7, _print_and_wait
	mov #txt_lore_03, r2
	jsr r7, _print_and_wait
	mov #txt_lore_04, r2
	jsr r7, _print_and_wait
	mov #txt_lore_05, r2
	jsr r7, _print_and_wait
	mov #txt_lore_06, r2
	jsr r7, _print_and_wait
	mov #txt_lore_07, r2
	jsr r7, _print_and_wait
	mov #txt_lore_08, r2
	jsr r7, _print_and_wait
	mov #txt_lore_09, r2
	jsr r7, _print_and_wait
	mov #txt_lore_10, r2
	jsr r7, _print_and_wait
	mov #txt_lore_11, r2
	jsr r7, _print_and_wait
	mov #txt_lore_12, r2
	jsr r7, _print_and_wait
	mov #txt_lore_13, r2
	jsr r7, _print_and_wait
	mov #txt_lore_14, r2
	jsr r7, _print_and_wait
	mov #txt_lore_15, r2
	jsr r7, _print_and_wait
	mov #txt_lore_16, r2
	jsr r7, _print_and_wait
	mov #txt_lore_17, r2
	jsr r7, _print_and_wait
	mov #txt_lore_18, r2
	jsr r7, _print_and_wait
	mov #txt_lore_19, r2
	jsr r7, _print_and_wait
	mov #txt_lore_20, r2
	jsr r7, _print_and_wait
	mov #txt_lore_21, r2
	jsr r7, _print_and_wait
	mov #txt_lore_22, r2
	jsr r7, _print_and_wait
	mov #txt_lore_23, r2
	jsr r7, _print_and_wait
	mov #txt_lore_24, r2
	jsr r7, _print_and_wait
	mov #txt_lore_25, r2
	jsr r7, _print_and_wait
	mov #txt_lore_26, r2
	jsr r7, _print_and_wait
	mov #txt_lore_27, r2
	jsr r7, _stdio_print
	jsr r7, _stdio_anykey

skip_lore:
	jsr r7, _stdio_clear
	mov #txt_enter_word, r2
	jsr r7, _print_and_wait

;Inserir a palavra secreta
enter_word:
	;Solicitar a palavra secreta 
	mov #txt_enter_word_prompt, r2
	jsr r7, _stdio_print
	jsr r7, _stdio_in

	;Extrair a palavra secreta do usuário e converter para maiúsculas caso seja válida
	mov #secret_word, r3
	jsr r7, _stdio_input_flush_bytes ;Como array de bytes, conforme a especificação do trabalho

	mov #secret_word-1, r2

	;Primeira verificação: verificar se está vazia
	mov (r2), r0
	and #h00FF, r0 ;Trata apenas o byte menos significativo
	beq enter_word_invalid

	cmp r0, #'-'
	beq enter_word_invalid ;Palavras não podem começar com hífen

	;_game_valid_char recebe qualquer valor não-nulo em r4 para verificar hífen,
	;e sabe-se que r0 não é nulo, então é seguro colocá-lo em r4
	mov r0, r4 

;Verificar se a palavra secreta inserida é válida
enter_word_loop:
	;Verificar se ultrapassou o limite de 25 caracteres, conforme as especificações do trabalho.
	;Note que `secret_word+24` é o endereço do caractere 25,
	;mas como é uma array de bytes, r2 sempre aponta para o byte anterior.
	cmp r2, #secret_word+23 
	bhi enter_word_max ;Se ultrapassou, é inválido
	
	;Verificar se o caractere é válido
	jsr r7, _game_valid_char ;Essa subrotina testa r0 setado abaixo
	beq enter_word_invalid

	;É válido. Próximo loop.
	inc r2
	mov (r2), r0
	cmp r0, #h2D2D ;0x2D é o código ASCII do hífen. Então 0x2D2D representam dois hífens seguidos.
	beq enter_word_invalid ;Se houver dois hífens seguidos, é inválido.

	and #h00FF, r0 ;Trata apenas o byte menos significativo

	;Se chegar no null terminator, a palavra é válida
	;Senão, continuar o loop
	bne enter_word_loop
	br enter_word_end

enter_word_invalid:
	jsr r7, _stdio_clear
	mov #txt_enter_word_invalid, r2
	jsr r7, _stdio_print
	jsr r7, _stdio_anykey
	
	jsr r7, _stdio_clear
	br enter_word

enter_word_max:
	jsr r7, _stdio_clear
	mov #txt_enter_word_invalid, r2 ;Imprimir "Inválido"
	jsr r7, _print_and_wait
	mov #txt_enter_word_max, r2 ;Imprimir "Limite de 25 caracteres"
	jsr r7, _print_and_wait
	br enter_word

enter_word_end:
	;Verificar se a palavra secreta termina com hífen
	cmp (r2), #h2D00 ;0x2D é o código ASCII do hífen, e sabe-se que (r2) é nulo.
	beq enter_word_invalid ;Palavras não podem terminar com hífen

	jsr r7, _str_to_upper_bytes ;Como array de bytes, conforme a especificação do trabalho

enter_lives:
	;Pedir o número de vidas ao jogador
	jsr r7, _stdio_clear
	mov #txt_enter_lives, r2
	jsr r7, _stdio_print

	;Receber o número de vidas do jogador
	jsr r7, _stdio_in
	mov #strbuf36, r3
	jsr r7, _stdio_input_flush

	;Verificar se está vazio
	mov strbuf36, r0
	beq enter_lives_invalid ;Se estiver, é inválido

	;Tem pelo menos um dígito
	;Verificar se tem um segundo dígito
	mov strbuf36+2, r1
	bne enter_lives_double_digit ;Se tiver, tratar como dois dígitos

	;Senão, pular a parte que trata as dezenas
	br enter_lives_single_digit

;Tem dois dígitos
;Tratar o primeiro caractere (r1) como as dezenas e o segundo (r0) como unidades
enter_lives_double_digit:
	;Tem pelo menos dois dígitos
	;Verificar se há mais de dois dígitos
	tst strbuf36+4
	bne enter_lives_invalid ;Se houver, é inválido

	;Dezenas
	cmp r0, #'9' ;Verificar se a dezena é maior que 9 (inválido)
	bhi enter_lives_invalid

	sub #'0', r0 ;Converter as dezenas de ASCII e verificar se é menor que 0 (inválido)
	bcs enter_lives_invalid

	mov r1, -(r6) ;Armazenar as unidades

	mov #10, r1
	jsr r7, _math_mul_u16 ;Multiplicar as dezenas por 10. Essa operação não pode causar overflow.
	mov r2, r1 ;Mover o resultado para r1

	mov (r6)+, r0 ;Restaurar as unidades

enter_lives_single_digit:
	;Unidades
	cmp r0, #'9' ;Verificar se a unidade é maior que 9 (inválido)
	bhi enter_lives_invalid

	sub #'0', r0 ;Converter as unidades de ASCII e verificar se é menor que 0 (inválido)
	bcs enter_lives_invalid

 	;Somar as unidades às dezenas.
	;Perceba que, se houver apenas um dígito, r1 = 0
	add r0, r1
	beq enter_lives_invalid ;Não é permitido 0 vidas
	
	mov r1, lives ;Armazenar o número de vidas
	br game_setup

;Erro parseando o número de vidas
;O jogador deverá inserir um novo número
enter_lives_invalid:
	jsr r7, _stdio_clear
	mov #txt_enter_lives_invalid, r2
	jsr r7, _stdio_print
	jsr r7, _stdio_anykey
	br enter_lives

game_setup:
	jsr r7, _stdio_clear

	clr clock ;Zerar o timer
	clr guess_mask ;Zerar a máscara de letras usadas
	clr guess_mask+2

	;Copiar a palavra secreta para a palavra secreta escondida, substituindo os caracteres por '_'
	mov #secret_word-1, r3
	mov #secret_word_hidden, r4

game_hide_word_loop:
	mov (r3), r0
	and #h00FF, r0 ;Trata apenas o byte menos significativo
	beq game_hide_word_end
	
	inc r3
	cmp r0, #'-'
	beq game_hide_word_skip_replace

	mov #'_', r0

game_hide_word_skip_replace:
	mov r0, (r4)+
	br game_hide_word_loop

game_hide_word_end:
game_setup_interrupt:
	clr (r4) ;Null terminator

	;Configurar a interrupção do teclado
	mov #_game_guess, isr_keyboard
	jsr r7, _isr_enable_keyboard

	;Configurar a interrupção do timer
	mov #_game_update_timer, isr_timer
	jsr r7, _isr_enable_timer
	mov #250, timdt ;Ativar o timer

;Atualizar o diplay enquanto o jogador ainda tem vidas
game_loop:
	;Verificar se o jogador ainda tem vidas
	;É melhor utilizar `ble` em vez de `beq` para o caso de uma situação inesperada causar `lives` negativo 
	tst lives
	ble game_lost ;`ble`, junto com tst, checa se N ou Z estão ligados. `cmp` não é necessário.

	;Verificar se a palavra foi descoberta
	mov #secret_word_hidden, r2
	mov #'_', r1
	jsr r7, _str_find
	tst r2
	beq game_won

	jsr r7, _game_draw
	br game_loop

;As vidas acabaram
game_lost:
	;Escrever "Você perdeu!" no display
	jsr r7, _stdio_clear
	mov #txt_game_lost, r2
	jsr r7, _stdio_print
	br game_over

;A palavra foi adivinhada
game_won:
	;Escrever "Você venceu!" no display
	jsr r7, _stdio_clear
	mov #txt_game_won, r2
	jsr r7, _stdio_print

;Procedimentos comuns a ganhar e perder no fim do jogo
game_over:
	mov #display+16, stdio_cursor ;Posicionar o cursor para escrever o timer à direita

	mov #txt_time_elapsed, r2 ;Escrever "Tempo de jogo:" no display
	jsr r7, _stdio_print

	;Escrever o timer no display
	mov clock, r0 ;Número de ticks desde o início do jogo (250 ms)
	asr r0 ;Número de ticks / 2 (500ms)
	asr r0 ;Segundos desde o início do jogo
	mov #60, r1 ;60 segundos por minuto
	jsr r7, _math_div_u16 ;Dividir o número de segundos por 60
	mov r3, -(r6) ;Armazenar o resto da divisão

	mov #strbuf36, r5 ;Buffer para o qual o tempo será convertido para string
	mov r2, r0 ;r2 contém o número de minutos
	jsr r7, _str_from_u16 ;Converter os minutos para string
	mov r5, r2
	add #6, r2 ;Escrever apenas os dois últimos dígitos
	jsr r7, _stdio_print ;Imprimir os minutos

	mov #txt_colon, r2 ;Separador de minutos e segundos
	jsr r7, _stdio_print ;Imprimir o separador
	
	mov #strbuf36, r5
	mov (r6)+, r0 ;O resto da divisão são os segundos
	jsr r7, _str_from_u16 ;Converter os segundos para string
	mov r5, r2
	add #6, r2 ;Escrever apenas os dois últimos dígitos
	jsr r7, _stdio_print ;Imprimir os segundos
	jsr r7, _isr_waitfor_keyboard ;Esperar o jogador pressionar qualquer tecla
	jsr r7, _stdio_clear
	
game_play_again:
	;Perguntar se o jogador quer jogar novamente
	mov #txt_play_again_prompt, r2
	jsr r7, _stdio_print
	jsr r7, _stdio_yn
	beq game_exit
	bgt game_restart

;Entrada inválida
game_play_again_invalid:
	jsr r7, _stdio_clear
	mov #txt_yn_invalid, r2
	jsr r7, _print_and_wait

	mov #txt_yn_invalid_y, r2
	jsr r7, _print_and_wait
	mov #txt_yn_invalid_n, r2
	jsr r7, _print_and_wait

	br game_play_again ;Repetir a pergunta

game_restart:
	jsr r7, _stdio_clear
	jmp restart_point ;Reiniciar o jogo

game_exit:
	jsr r7, _stdio_clear
	mov #txt_exit, r2
	jsr r7, _stdio_print
	rts r7 ;Terminar o programa


;print_and_wait(buffer r2)
_print_and_wait:
	jsr r7, _stdio_print
	jsr r7, _stdio_anykey
	jsr r7, _stdio_clear
	rts r7


;game_valid_char(char r0, bool r4) : r1
;Verificar se o caractere em r0 é um caractere válido para a palavra secreta (letra ou hífen).
;Se r4 for 0, não verificar hífen
;Retorna 1 caso seja válido, 0 caso contrário
_game_valid_char:
	;Testar maiúsculas
	cmp r0, #'Z'
	bhi game_valid_char_not_upper

	cmp r0, #'A'
	bcc game_valid_char_true

	;Testar hífen
	tst r4 ;Verificar se deve testar hífen. Senão, não é válido.
	beq game_valid_char_false ;Abaixo de 'A' apenas tem '-'
	cmp r0, #'-'
	beq game_valid_char_true
	br game_valid_char_false

game_valid_char_not_upper:
	;Testar minúsculas
	cmp r0, #'a'
	bcs game_valid_char_false

	cmp r0, #'z'
	bhi game_valid_char_false

game_valid_char_true:
	mov #1, r1
	rts r7

game_valid_char_false:
	clr r1
	rts r7


;game_update_timer()
;Interrupção do timer.
_game_update_timer:
	inc clock
	rts r7


;game_guess()
;Interrupção do teclado.
;Tentativa do jogador de adivinhar uma letra da palavra secreta.
_game_guess:
	mov tecdt, r0

	;Verificar se o caractere é válido
	clr r4 ;_game_valid_char recebe 0 em r4 para não verificar hífen
	jsr r7, _game_valid_char
	beq game_guess_invalid ;Branch se caractere é inválido

	;Caractere é válido
	;Converter para maiúsculas
	cmp r0, #'a'
	bcs game_guess_skip_upper ;Não é minúscula. Pular to-upper

	sub #32, r0 ;'A' - 'a' = -32

game_guess_skip_upper:
	;Verificar se o caractere já foi usado
	mov r0, r1 ;Copiar r0 para r1 para não alterar r0
	cmp r1, #'Q' ;'Q' é o primeiro bit da palavra mais significativa
	bcs game_guess_mask_low ;Se for menor que 'Q', utiliza o segundo byte da máscara

;Senão, utilizar o primeiro byte da máscara
game_guess_mask_high:
	sub #'Q', r1 ;r1 agora contém a posição da letra no alfabeto a partir de 'Q' (0 => 'Q', 1 => 'R', ..., 9 => 'Z')
	mov #guess_mask, r2 ;r2 contém o endereço do primeiro byte da máscara
	br game_guess_mask_check

game_guess_mask_low:
	sub #'A', r1 ;r1 agora contém a posição da letra no alfabeto (0 => 'A', 1 => 'B', ..., 15 => 'P')
	mov #guess_mask+2, r2 ;r2 contém o endereço do segundo byte da máscara

;Mapear a posição da letra para a máscara correspondente e verificar se o bit está ligado
game_guess_mask_check:
	asl r1 ;r1 agora contém o offset do mapa de máscaras
	mov guess_mask_map(r1), r1 ;r1 agora contém a máscara correspondente à letra
	mov r1, r3 ;Copiar para r3 para não perder o valor de r1
	and (r2), r3 ;r3 será zero se e somente se o bit correspondente à letra estiver desligado
	bne game_guess_invalid ;É inválido se a letra já foi usada

	;Senão, é letra válida.
	or r1, (r2) ;Ligar o bit correspondente à letra na máscara

	;Preparar o loop para procurar a letra na palavra secreta
	mov #secret_word-1, r2
	clr r3 ;r3 é uma flag que indica se o caractere foi encontrado alguma vez

;Verificar se o caractere está contido na palavra secreta
game_guess_loop:
	mov (r2), r1
	and #h00FF, r1 ;Trata apenas o byte menos significativo
	beq game_guess_end ;Termina se for null
	inc r2

	cmp r1, r0 ;Testa se o caractere inserido é igual ao caractere da palavra secreta sendo testado
	bne game_guess_loop ;Se não for, testar o próximo caractere

;Caractere foi encontrado
game_guess_found:
	inc r3 ;Indica que o caractere foi encontrado
	mov r2, r1
	sub #secret_word, r1 ;r1 agora contém o offset do caractere na palavra secreta
	asl r1 ;A palavra secreta é array de bytes, enquanto a palavra secreta escondida é array de words
	mov r0, secret_word_hidden(r1) ;Substituir o caractere na palavra secreta escondida
	br game_guess_loop

game_guess_end:
	tst r3
	bne game_guess_skip_not_found ;Branch se a letra foi encontrada na palavra

;Letra não foi encontrada
game_guess_not_found:
	dec lives ;Decrementar o número de vidas

	bhi game_guess_skip_lost ;Verificar se o jogador ainda tem vidas

	;Vidas acabaram
	jsr r7, _isr_disable_keyboard ;Bloquear o teclado
	jsr r7, _isr_disable_timer ;Parar o timer
	;Devolver o controle do jogo ao loop principal

game_guess_skip_lost:
game_guess_skip_not_found:
game_guess_invalid:
	rts r7


;game_draw()
;Atualizar o display.
_game_draw:
	jsr r7, _stdio_free ;"Limpar" o display sem alterar o conteúdo. É mais otimizado que _stdio_clear.

	mov #secret_word_hidden, r2
	jsr r7, _stdio_print ;Imprimir a palavra secreta à esquerda

	;Preencher a área entre a palavra e as vidas com espaços, conforme as especificações do trabalho
	mov #display+27, r0
	mov stdio_cursor, r1
	sub r1, r0 ;r0 agora contém quantos caracteres faltam para escrever até `#display+26`
	beq game_draw_skip_padding ;Se não faltar nenhum, não precisa preencher com espaços

game_draw_padding_loop:
	mov #' ', (r1)
	inc r1
	sob r0, game_draw_padding_loop

game_draw_skip_padding:
	mov r1, stdio_cursor ;Posicionar o cursor após a operação

	mov #txt_ui_lives, r2
	jsr r7, _stdio_print ;Imprimir texto de vidas à direita

	;Converter para string e imprimir o número de vidas à direita
	mov lives, r0
	mov #strbuf36, r5
	jsr r7, _str_from_u16
	mov #strbuf36+6, r2
	jsr r7, _stdio_print

	rts r7




;+=================================================================================================+
;|                                                                                                 |
;|                                         BIBLIOTECAS                                             |
;|       																				           |
;+-------------------------------------------------------------------------------------------------+

; <str>


;str_find(string r2, char r1) : r2
;Procurar o caractere r1 na string r2.
;Retorna o endereço do caractere em r2 caso seja encontrado, 0 caso contrário
_str_find:
str_find_loop:
	mov (r2)+, r0
	beq str_find_not_found

	cmp r0, r1
	bne str_find_loop ;Não é o caractere procurado. Testar o próximo caractere.

;Caractere encontrado. r2 contém o endereço do próximo caractere.
str_find_found:
	sub #2, r2 ;r2 agora contém o endereço do caractere encontrado
	rts r7

str_find_not_found:

	clr r2
	rts r7


;str_to_upper(buffer r3)
;Converter a null-terminated string do buffer cujo endereço inicial está em r3 para maiúsculas.
_str_to_upper:
	mov r3, r2

str_to_upper_loop:
	mov (r2)+, r4
	beq str_to_upper_end
	cmp r4, #'a'
	bcs str_to_upper_loop

	cmp r4, #'z'
	bhi str_to_upper_loop

	;r4 contém um caractere minúsculo
	;Converter para maiúsculo
	sub #32, r4 ;'A' - 'a' = -32
	mov r4, -2(r2)
	br str_to_upper_loop

str_to_upper_end:
	rts r7


;str_to_upper_bytes(buffer r3)
;Faz a mesma coisa que str_to_upper() mas sobre uma array de bytes.
_str_to_upper_bytes:
	mov r3, r2
	dec r2 ;Começar do byte anterior ao buffer

str_to_upper_bytes_loop:
	;Salva o valor do byte anterior ao buffer.
	mov (r2), r5
	beq str_to_upper_bytes_end ;Encerra se for null
	mov r5, r4 ;Perceba que, aqui, (r2) = r5 = r4
	and #h00FF, r4 ;Age apenas sobre o byte menos significativo.
	and #hFF00, r5 ;Salva o byte mais significativo original (poderá ser sobrescrito).
	
	inc r2
	cmp r4, #'a'
	bcs str_to_upper_bytes_loop

	cmp r4, #'z'
	bhi str_to_upper_bytes_loop

	;r4 contém um caractere minúsculo
	;Converter para maiúsculo
	sub #32, r4 ;'A' - 'a' = -32
	mov r4, -1(r2)
	add r5, -1(r2) ;Restaura o byte anterior.
	br str_to_upper_bytes_loop

str_to_upper_bytes_end:
	add r5, (r2) ;Restaura o byte anterior.
	rts r7


;str_to_lower(buffer r3)
;Converter a null-terminated string do buffer cujo endereço inicial está em r3 para minúsculas.
_str_to_lower:
	mov r3, r2

str_to_lower_loop:
	mov (r2)+, r4
	beq str_to_lower_end
	cmp r4, #'A'
	bcs str_to_lower_loop

	cmp r4, #'Z'
	bhi str_to_lower_loop

	;r4 contém um caractere maiúsculo
	;Converter para minúsculo
	add #32, r4 ;'a' - 'A' = 32
	mov r4, -2(r2)
	br str_to_lower_loop

str_to_lower_end:
	rts r7


;str_from_u16(u16 r0, string r5)
;Converte o inteiro unsigned para null-terminated string
;Retorna em r0 o endereço do algarismo mais significativo não-nulo ou zero caso todos os algarismos sejam nulos
_str_from_u16:
	add #10, r5  ;r5 agora aponta para o último caractere da string
	clr (r5)     ;Null terminator
	mov #5, r4   ;Iterador. Um u16 consegue ter no máximo 5 dígitos 
	mov #10, r1  ;Divisor
	tst r0
	bne str_from_u16_div_loop
	mov r5, r0
	sub #2, r0 ;r0 agora aponta para o último caractere da string
	br str_from_u16_padding_loop

str_from_u16_div_loop:
	beq str_from_u16_padding ;Quando o dividendo for 0, terminar

	mov r4, -(r6) ;_math_div_u16 altera r4
	jsr r7, _math_div_u16 ;Dividir por 10
	mov (r6)+, r4
	;r2 contém o número com o dígito menos significativo removido
	;r3 contém o dígito menos significativo

	add #'0', r3  ;Converter o dígito de BCD para ASCII
	mov r3, -(r5) ;Armazenar o caractere do dígito na string
	mov r2, r0    ;Preparar o dividendo para a próxima iteração
	sob r4, str_from_u16_div_loop

	mov r5, r0 ;r0 contém o endereço do algarismo mais significativo não-nulo
	br str_from_u16_end ;Se todos os dígitos foram usados, não precisa preencher com zeros

;Senão, preencher os dígitos não usados com zeros
str_from_u16_padding:
	mov r5, r0 ;r0 contém o endereço do algarismo mais significativo não-nulo

str_from_u16_padding_loop:
	mov #'0', -(r5)
	sob r4, str_from_u16_padding_loop ;r4 contém o número de dígitos não preenchidos

str_from_u16_end:
	rts r7

;+-------------------------------------------------------------------------------------------------+

; <math>


;math_mul_u16(u16 r0, u16 r1)
;Multiplicar r0 por r1 e armazena o resultado em r2
;Se houver overflow, a flag V estará ligada, e r2 não representará o resultado correto
_math_mul_u16:
	clr r2 ;r2 é o resultado parcial

	ccc C
	ror r1 ;Isso fica fora do loop porque o bit mais significativo pode ser 1, então asr não funciona
	bne math_mul_loop_add ;Entrar no loop

	;A não ser que o multiplicador seja 0
	;Nesse caso, r2 já está zerado, então retorna
	rts r7

math_mul_loop:
	asl r0 ;Deslocar o multiplicando parcial para a esquerda
	bcs math_mul_loop_carry ;Carry do multiplicando parcial

	asr r1 ;Extrair o próximo bit menos significativo do multiplicador
	beq math_mul_success ;Terminar quando o multiplicador chegar a zero

;Verificar se deve somar, e se sim, somar
math_mul_loop_add:
	bcc math_mul_loop ;Se o bit do multiplicador parcial for 0, não precisa somar.

	add r0, r2 ;Se for 1, somar o multiplicando parcial ao resultado parcial
	bvc math_mul_loop ;Se não houver overflow, continuar o loop
	;Senão, terminar com a flag V ligada

math_mul_end:
	rts r7

;O multiplicador chegou a zero. Realizar a última soma.
;Sempre haverá a última soma pois senão o multiplicador seria 0 na iteração anterior
math_mul_success:
	add r0, r2
	rts r7 ;V estará ligada caso haja overflow na soma acima

;Houve carry do multiplicando parcial
;Isso significa que houve overflow, já que se sabe que o multiplicador parcial é maior que zero
math_mul_loop_carry:
	scc V ;Ligar a flag V
	rts r7 ;Terminar com overflow


;math_div_u16(u16 r0, u16 r1)
;Divide r0 por r1 e armazena o quociente em r2 e o resto em r3
;Caso o divisor seja 0, retorna 0 em r2 e coloca o dividendo em r3
_math_div_u16:
	;Divisão por 0
	tst r1
	beq math_div_u16_byzero
	
	mov #16, r4 ;Iterador
	clr r3 ;Dividendo parcial

math_div_u16_loop:
	;Extrair o bit mais significativo do dividendo
	asl r0
	rol r3

	;Caso o dividendo parcial seja maior ou igual ao divisor, subtrair o divisor do dividendo parcial
	cmp r3, r1
	bcs math_div_u16_not_sub

	sub r1, r3
	scc C ;Inserir 1 no bit correspondente do quociente
	br math_div_u16_loop_end

math_div_u16_not_sub:
	ccc C ;Inserir 0 no bit correspondente do quociente

math_div_u16_loop_end:
	rol r2 ;Inserir o bit no quociente
	sob r4, math_div_u16_loop

math_div_u16_end:
	rts r7

math_div_u16_byzero:
	clr r2
	mov r0, r3
	rts r7

;+-------------------------------------------------------------------------------------------------+

; <stdio>


stdio_cursor:    DW   ;Endereço de memória do primeiro byte vazio do display
stdio_input_start: DW ;Endereço de memória do primeiro byte do display que contém input do usuário


;stdio_init()
;Inicializar o display e o teclado.
_stdio_init:
	clr stdio_cursor ;Mandar limpar o display inteiro
	jsr r7, _stdio_clear   ;Limpar o display
	rts r7


;stdio_print(buffer r2)
;Imprimir a null-terminated string do buffer cujo endereço inicial está em r2 no display.
;Continua o texto anterior caso não tenha sido limpo.
_stdio_print:
	mov stdio_cursor, r5

stdio_print_loop:
	cmp r5, #display+35
	bgt stdio_print_end ;Para caso o display esteja cheio
	mov (r2)+, r4
	beq stdio_print_end ;Para caso o texto tenha terminado
	mov r4, (r5)
	inc r5
	br stdio_print_loop

stdio_print_end:
	mov r5, stdio_cursor
	rts r7


;stdio_clear()
;Limpar o display.
_stdio_clear:
	mov stdio_cursor, r5
	sub #display, r5 ;r5 agora contém o offset do último byte com texto do display
	ble stdio_clear_end ;Caso o display já esteja vazio, terminar
	
stdio_clear_loop:
	clr 65499(r5) ;Por algum motivo, escrever `display-1(r5)` não funciona
	sob r5, stdio_clear_loop
	mov #display, stdio_cursor

stdio_clear_end:
	rts r7


;stdio_free()
;Virtualmente limpar o display sem alterar o conteúdo do display.
;É mais otimizado que `stdio_clear` pois não precisa escrever no display.
;Deve ser usado quando o conteúdo do display será sobrescrito.
_stdio_free:
	mov #display, stdio_cursor
	rts r7


;stdio_in()
;Receber input do usuário até `return` ser pressionado.
;Usar `_stdio_input_flush` para armazenar o conteúdo do display em um buffer
_stdio_in:
	clr tecst
	mov stdio_cursor, r5
	mov r5, stdio_input_start
	mov #255, timdt
	clr r1

stdio_in_cursor:
	clr ints

	;Caso o display esteja cheio, não tenta desenhar o cursor
	;`bgt` em vez de `bhi` por causa do overflow
	cmp r5, #display+35
	bgt stdio_in_read

	tst r1
	bne stdio_in_cursor_hide

	mov #'|', (r5)
	inc r1
	br stdio_in_read

stdio_in_cursor_hide:
	clr (r5)
	dec r1
	br stdio_in_read

stdio_in_wait:
	mov ints, r0
	and #h01, r0
	bne stdio_in_cursor

stdio_in_read:
	tst tecst
	beq stdio_in_wait
	mov tecdt, r4
	clr tecst

	cmp r5, #display+35
	bgt stdio_in_skip_clear

	clr (r5)

stdio_in_skip_clear:
stdio_in_backspace:
	cmp r4, #h08 ;Backspace
	bne stdio_in_return

	cmp r5, stdio_input_start
	beq stdio_in_wait
	dec r5
	clr (r5)
	br stdio_in_wait

stdio_in_return:
	cmp r4, #h0D ;Return
	bne stdio_in_default

	mov r5, stdio_cursor
	rts r7

;Não é caractere especial. Imprime-o no display.
stdio_in_default:
	cmp r5, #display+35

	;`bgt` em vez de `bhi` por causa do overflow
	bgt stdio_in_wait
	
	mov r4, (r5)
	inc r5
	br stdio_in_wait


;stdio_input_flush(buffer r3)
;Armazenar o conteúdo do display no buffer cujo endereço inicial está em r3 e limpar o display.
_stdio_input_flush:
	mov r3, r2 ;Copiar r3 para não alterar r3
	mov stdio_input_start, r4 ;Iterador
	sub #display, r4 ;r4 agora contém o offset do buffer inicial
	mov #36, r5

;Loop começa em `stdio_input_start` e termina em `stdio_cursor`
stdio_input_flush_loop:
	mov display(r4), (r2)+ ;Copia o caractere
	beq stdio_input_flush_end ;Termina se for null

	clr display(r4) ;Limpa o caractere do display

	inc r4
	cmp r4, r5
	bcs stdio_input_flush_loop ;Quando `r4 = 36`, o buffer está cheio

stdio_input_flush_end:
	mov stdio_input_start, stdio_cursor
	rts r7


;stdio_input_flush_bytes(buffer r3)
;Faz a mesma coisa que stdio_input_flush() mas para uma array de bytes.
_stdio_input_flush_bytes:
	mov r3, r2 ;Copiar r3 para não alterar r3
	dec r2 ;Começar do byte anterior ao buffer
	mov stdio_input_start, r4 ;Iterador
	sub #display, r4 ;r4 agora contém o offset do buffer inicial

;Loop começa em `stdio_input_start` e termina em `stdio_cursor`
stdio_input_flush_bytes_loop:
	mov (r2), r5 ;Salva o valor anterior do byte anterior ao buffer.
	and #hFF00, r5 ;Salva apenas o byte mais significativo.

	mov display(r4), (r2) ;Copia o caractere (apenas a parte mais significativa, sobrescrevendo o byte anterior com 0)
	beq stdio_input_flush_bytes_end ;Acaba se for null

	add r5, (r2) ;Restaura o byte anterior.

	clr display(r4) ;Limpa o caractere do display

	inc r2
	inc r4
	cmp r4, #36
	bcs stdio_input_flush_bytes_loop ;Quando `r4 = 36`, o buffer está cheio

stdio_input_flush_bytes_end:
	add r5, (r2) ;Restaura o byte anterior uma última vez.
	mov stdio_input_start, stdio_cursor
	rts r7


;stdio_anykey()
;Pausar o programa até que uma tecla qualquer seja pressionada.
_stdio_anykey:
	mov display+35, r4 ;Guardar o último byte do display
	mov #h3E, display+35 ;Desenhar '>' no último byte do display
	jsr r7, _isr_waitfor_keyboard

	mov r4, display+35 ;Recuperar o último byte do display
	rts r7


;stdio_yn() : r0
;Pegar input do usuário de perguntas de sim ou não
;Retorna em r0 0 se o usuário respondeu não, 1 se respondeu sim, e -1 se a entrada for inválida
;As flags Z e N estarão relacionadas a r0, e V sempre estará desligada
_stdio_yn:
	;Receber a resposta do jogador (s/n)
	jsr r7, _stdio_in
	mov #strbuf36, r3
	jsr r7, _stdio_input_flush

	;Verificar se há apenas um caractere
	tst strbuf36+2
	bne stdio_yn_invalid

	;Sim
	cmp (r3), #'s'
	beq stdio_yn_yes
	cmp (r3), #'S'
	beq stdio_yn_yes

	;Não
	cmp (r3), #'n'
	beq stdio_yn_no
	cmp (r3), #'N'
	beq stdio_yn_no

stdio_yn_invalid:
	mov #-1, r0
	rts r7

stdio_yn_yes:
	mov #1, r0
	rts r7

stdio_yn_no:
	clr r0
	rts r7

;+-------------------------------------------------------------------------------------------------+

; <isr>

;Ponteiro para a subrotina a ser chamada quando ocorrer uma interrupção do timer.
;É uma camada de abstração por cima do IVET
isr_timer:    DW 0

;Ponteiro para a subrotina a ser chamada quando ocorrer uma interrupção do teclado.
;É uma camada de abstração por cima do IVET
;Dentro da ISR do teclado, tecdt contém o caractere pressionado e não é alterado.
;O usuário só poderá inserir um novo caractere após a ISR do teclado terminar.
isr_keyboard: DW 0


;isr_init()
;Inicializar a rotina de interrupções.
_isr_init:
	clr isr_timer ;Null
	clr isr_keyboard ;Null
	mov #i_isr_routine, ivet
	mov #h80, inte
	clr ints
	rts r7


;isr_enable_timer()
;Habilitar a interrupção do timer
_isr_enable_timer:
	or #h01, inte  ;Habilitar interrupção do timer
	and #hFE, ints ;Limpar status do timer
	rts r7


;isr_disable_timer()
;Desabilitar a interrupção do timer
_isr_disable_timer:
	and #hFE, inte ;Desabilitar interrupção do timer
	clr isr_timer  ;isr_timer = NULL
	rts r7


;isr_enable_keyboard()
;Habilitar a interrupção do teclado
_isr_enable_keyboard:
	or #h02, inte  ;Habilitar interrupção do teclado
	and #hFD, ints ;Limpar status do teclado
	clr tecst      ;Limpar status do teclado
	rts r7


;isr_disable_keyboard()
;Desabilitar a interrupção do teclado
_isr_disable_keyboard:
	and #hFD, inte   ;Desabilitar interrupção do teclado
	clr isr_keyboard ;isr_keyboard = NULL
	rts r7


;isr_routine()
;Rotina a ser chamada quando ocorrer uma interrupção de qualquer natureza.
;É uma camada de abstração por cima de colocar o endereço da ISR no IVET.
;No lugar disso, esta subrotina deve ser colocada no IVET através de isr_init(), e a subrotina
;que de fato trata a interrupção deve ser colocada em isr_timer ou isr_keyboard, para timer e
;teclado, respectivamente.
;É necessário salvar e restaurar todos os registradores de uso geral utilizados no tratador de
;interrupção.
i_isr_routine:
	;Armazenar registradores de uso geral
	mov r0, -(r6)
	mov r1, -(r6)
	mov r2, -(r6)
	mov r3, -(r6)
	mov r4, -(r6)
	mov r5, -(r6)

isr_routine_test_timer:
	tst isr_timer
	beq isr_routine_test_keyboard ;isr_timer é NULL
	
	;Interrupção de timer está habilitada
	mov ints, r0
	and #h01, r0
	beq isr_routine_test_keyboard ;Timer não causou a interrupção

	;Timer causou a interrupção
	mov isr_timer, r0
	jsr r7, (r0) ;A subrotina deve ser chamada indiretamente pois `(isr_timer)` não é válido
	and #hFE, ints ;Limpar status do timer

isr_routine_test_keyboard:
	tst isr_keyboard
	beq isr_routine_end ;isr_keyboard é NULL

	;Interrupção de teclado está habilitada
	mov ints, r0
	and #h02, r0
	beq isr_routine_end ;Teclado não causou a interrupção

	;Teclado causou a interrupção
	mov isr_keyboard, r0
	jsr r7, (r0) ;A subrotina deve ser chamada indiretamente pois `(isr_timer)` não é válido
	and #hFD, ints ;Limpar status do teclado
	clr tecst ;Permitir que o teclado cause outra interrupção

isr_routine_end:
	;Restaurar registradores de uso geral
	mov (r6)+, r5
	mov (r6)+, r4
	mov (r6)+, r3
	mov (r6)+, r2
	mov (r6)+, r1
	mov (r6)+, r0

	rti


isr_waitfor_keyboard_triggered: DW

;isr_waitfor_keyboard()
;Pausar o programa até que uma tecla seja pressionada.
_isr_waitfor_keyboard:
	mov #_isr_waitfor_keyboard_interrupt, isr_keyboard
	jsr r7, _isr_enable_keyboard
	clr isr_waitfor_keyboard_triggered

isr_waitfor_keyboard_loop:
	tst isr_waitfor_keyboard_triggered
	beq isr_waitfor_keyboard_loop

	jsr r7, _isr_disable_keyboard
	rts r7

_isr_waitfor_keyboard_interrupt:
	inc isr_waitfor_keyboard_triggered
	rts r7




;+-------------------------------------------------------------------------------------------------+
;|                                                                                                 |
;|                                      ENDEREÇOS ESPECIAIS                                        |
;|       																				           |
;+-------------------------------------------------------------------------------------------------+

stack: EQU hFF80 ;Fundo da stack

ORG hFFBE
ivet: DW ;Vetor de interrupção - endereço da ISR (Interrupt Service Routine)

ORG hFFD7
timdt: DB ;(BYTE) Timer base time
ints:  DB ;(BYTE) Interrupt Status - Monitoramento do estado das interrupções
inte:  DB ;(BYTE) Interrupt Enable - Controle de habilitação das interrupções
tecst: DB ;(BYTE) Se o conteúdo deste endereço de memória for h80 então existe tecla disponível
tecdt: DB ;(BYTE) Dado do Teclado - Endereço a ser lido caso exista uma tecla disponível
display: DAB [36] ;(BYTE) 36 bytes do visor
